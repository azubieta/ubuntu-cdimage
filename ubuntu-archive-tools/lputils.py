# Copyright 2012 Canonical Ltd.
# Author: Colin Watson <cjwatson@ubuntu.com>

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 3 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

"""Launchpad API utility functions."""

from debian import debian_support


class PackageMissing(Exception):
    "Generic exception generated by `lputils`."

    def __init__(self, message=None):
        Exception.__init__(self, message)
        self.message = message


def setup_location(options, default_pocket="Release"):
    options.distribution = options.launchpad.distributions[
        options.distribution]
    if options.suite:
        if "-" in options.suite:
            options.series, options.pocket = options.suite.split("-", 1)
            options.pocket = options.pocket.title()
        else:
            options.series = options.suite
            options.pocket = "Release"
        options.series = options.distribution.getSeries(
            name_or_version=options.series)
    else:
        options.series = options.distribution.current_series
        options.pocket = default_pocket
        if options.pocket == "Release":
            options.suite = options.series.name
        else:
            options.suite = "%s-%s" % (
                options.series.name, options.pocket.lower())

    if getattr(options, "architecture", None) is None:
        options.architectures = list(options.series.architectures)
        # Manually filter out raring/armel; see LP #1077257
        if options.series.name == "raring":
            options.architectures = [
                a for a in options.architectures
                  if a.architecture_tag != "armel"]
    else:
        options.architectures = [options.series.getDistroArchSeries(
            archtag=options.architecture)]

    if getattr(options, "partner", False):
        options.archive = [archive for archive in options.distribution.archives
                           if archive.name == "partner"][0]
    elif getattr(options, "ppa", None):
        options.archive = options.launchpad.people[options.ppa].getPPAByName(
            name=options.ppa_name)
    else:
        options.archive = options.distribution.main_archive


def find_newest_publication(method, version_attr, **kwargs):
    """Hack around being unable to pass status=("Published", "Pending")."""
    if kwargs["version"] is not None:
        try:
            return method(**kwargs)[0]
        except IndexError:
            return None

    published_pubs = method(status="Published", **kwargs)
    pending_pubs = method(status="Pending", **kwargs)
    try:
        newest_published = published_pubs[0]
        newest_published_ver = getattr(newest_published, version_attr)
    except IndexError:
        try:
            return pending_pubs[0]
        except IndexError:
            return None
    try:
        newest_pending = pending_pubs[0]
        newest_pending_ver = getattr(newest_pending, version_attr)
    except IndexError:
        return newest_published
    if debian_support.version_compare(
        newest_published_ver, newest_pending_ver) > 0:
        return newest_published
    else:
        return newest_pending


def find_latest_published_binaries(options, package):
    target_binaries = []
    for architecture in options.architectures:
        binary = find_newest_publication(
            options.archive.getPublishedBinaries, "binary_package_version",
            binary_name=package, version=options.version,
            distro_arch_series=architecture, pocket=options.pocket,
            exact_match=True)
        if binary is not None:
            target_binaries.append(binary)
    if not target_binaries:
        raise PackageMissing(
            "Could not find binaries for '%s/%s' in %s" %
            (package, options.version, options.suite))
    return target_binaries


def find_latest_published_source(options, package):
    source = find_newest_publication(
        options.archive.getPublishedSources, "source_package_version",
        source_name=package, version=options.version,
        distro_series=options.series, pocket=options.pocket, exact_match=True)
    if source is None:
        raise PackageMissing(
            "Could not find source '%s/%s' in %s" %
            (package, options.version, options.suite))
    return source
